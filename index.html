<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>PeepSat</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 6px 8px;
      background: rgba(0,0,0,0.6);
      color: #fff;
      font-family: sans-serif;
      font-size: 12px;
      border-radius: 4px;
      z-index: 10;
    }
    #controls input, #controls select { font-size: 11px; }
    #controls button { font-size: 11px; margin: 2px; }
    #status {
      position: absolute;
      bottom: 10px;
      right: 10px;
      padding: 6px 8px;
      background: rgba(0,0,0,0.7);
      color: #0f0;
      font-family: monospace;
      font-size: 10px;
      border-radius: 4px;
      z-index: 10;
      max-width: 300px;
      max-height: 200px;
      overflow: auto;
    }
    #progress {
      position: absolute;
      bottom: 220px;
      right: 10px;
      padding: 6px 8px;
      background: rgba(0,0,0,0.8);
      color: #fff;
      font-family: sans-serif;
      font-size: 11px;
      border-radius: 4px;
      z-index: 10;
      min-width: 200px;
      display: none;
    }
    #progressBar {
      width: 100%;
      height: 20px;
      background: #333;
      border-radius: 3px;
      margin-top: 5px;
      overflow: hidden;
    }
    #progressFill {
      height: 100%;
      background: linear-gradient(90deg, #4CAF50, #8BC34A);
      width: 0%;
      transition: width 0.3s;
    }
    canvas { width: 100vw; height: 100vh; display: block; background: #000; }
  </style>
</head>
<body>
  <div id="controls">
    <label>Satellite
      <select id="satellite">
        <option value="19">GOES-19 (East/Atlantic)</option>
        <option value="18">GOES-18 (West/Pacific)</option>
        <option value="himawari">Himawari (Asia/Pacific)</option>
        <option value="meteosat9">Meteosat-9 (Indian Ocean)</option>
        <option value="meteosat10">Meteosat-10 (Africa/Europe)</option>
      </select>
    </label>
    <label>Resolution
      <select id="resolution">
        <option value="1808x1808">1808 (Low)</option>
        <option value="5424x5424" selected>5424 (High)</option>
        <option value="10848x10848">10848 (Ultra)</option>
      </select>
    </label>
    <!-- <label>Mask %<input id="maskRadius" type="number" min="30" max="55" step="0.5" value="50" size="4"></label> -->
    <input id="maskRadius" type="hidden" value="50">
    <br>
    <label>Offset X <input id="offsetX" size="5"></label>
    <label>Offset Y <input id="offsetY" size="5"></label>
    <label>Zoom <input id="zoom" size="3"></label>
    <br>
    <label>Hours <input id="hours" type="number" min="1" max="24" value="3" size="3"></label>
    <button id="load">Load</button>
    <button id="play">Play</button>
    <button id="pause">Pause</button>
    <label>FPS <input id="fps" type="number" min="1" max="30" value="5" size="2"></label>
    <br>
    <label>Frame <span id="frameInfo">0/0</span></label>
    <button id="share">Share</button>
    <label><input type="checkbox" id="autoUpdate" checked> Auto-update</label>
    <label><input type="checkbox" id="tileMode"> Tile mode</label>
  </div>
  <div id="progress">
    <div id="progressText">Loading images...</div>
    <div id="progressBar"><div id="progressFill"></div></div>
  </div>
  <div id="status"></div>
  <canvas id="canvas"></canvas>
  <script>
    const canvas = document.getElementById('canvas');
    const statusEl = document.getElementById('status');
    const progressEl = document.getElementById('progress');
    const progressText = document.getElementById('progressText');
    const progressFill = document.getElementById('progressFill');

    function log(msg) {
      statusEl.textContent += msg + "\n";
      statusEl.scrollTop = statusEl.scrollHeight;
    }

    const ctx = canvas.getContext('2d');

    // Image cache and animation - use window object directly
    window.imageCache = [];
    window.timestamps = [];
    window.currentFrame = -1;
    window.isPlaying = false;
    window.animationInterval = null;
    window.diskCircleCache = {}; // Cache detected disk per satellite: {satellite: {cx, cy, r}}

    function resize() {
      const oldW = canvas.width;
      const oldH = canvas.height;
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      // Redraw current frame on resize without changing zoom/pan
      if (window.currentFrame >= 0 && window.imageCache.length > 0) {
        drawImageToFit(window.imageCache[window.currentFrame]);
      }
    }
    window.addEventListener('resize', resize);
    resize();

    const params = new URLSearchParams(location.search);
    let centerX = parseFloat(params.get('cx') || '0.5');
    let centerY = parseFloat(params.get('cy') || '0.5');
    let zoom = parseFloat(params.get('z') || '1');
    let hours = parseInt(params.get('h') || '3');
    let satellite = params.get('sat') || '19'; // Default to GOES-19 (East)
    let resolution = params.get('res') || '5424x5424'; // Default to high res

    document.getElementById('offsetX').value = (centerX * 100).toFixed(2);
    document.getElementById('offsetY').value = (centerY * 100).toFixed(2);
    document.getElementById('zoom').value = String(zoom);
    document.getElementById('hours').value = hours;
    document.getElementById('satellite').value = satellite;
    document.getElementById('resolution').value = resolution;

    function updateUrl() {
      const p = new URLSearchParams();
      p.set('cx', centerX.toFixed(4));
      p.set('cy', centerY.toFixed(4));
      p.set('z', String(zoom));
      p.set('h', String(hours));
      p.set('sat', satellite);
      p.set('res', resolution);
      history.replaceState(null, '', '?' + p.toString());
    }

    function detectDiskRadius(img) {
      // Search from outside-in to find where Earth disk begins
      const tempCanvas = document.createElement('canvas');
      const w = img.naturalWidth;
      const h = img.naturalHeight;
      tempCanvas.width = w;
      tempCanvas.height = h;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(img, 0, 0);

      const imageData = tempCtx.getImageData(0, 0, w, h);
      const data = imageData.data;

      const cx = w / 2;
      const cy = h / 2;

      // Sample along 16 directions from outside in
      const numAngles = 16;
      let radii = [];

      for (let i = 0; i < numAngles; i++) {
        const angle = (i / numAngles) * Math.PI * 2;
        // Start from outside, move toward center
        for (let r = Math.floor(w * 0.52); r > Math.floor(w * 0.35); r--) {
          const x = Math.round(cx + r * Math.cos(angle));
          const y = Math.round(cy + r * Math.sin(angle));

          if (x < 0 || x >= w || y < 0 || y >= h) continue;

          const idx = (y * w + x) * 4;
          const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;

          // Found where Earth begins (transition from black to bright)
          if (brightness > 20) {
            radii.push(r);
            break;
          }
        }
      }

      // Use median of detected radii
      radii.sort((a, b) => a - b);
      const radius = radii.length > 0 ? radii[Math.floor(radii.length / 2)] : w * 0.49;

      return { cx, cy, r: radius };
    }

    function drawImageToFit(img) {
      if (!img) return;
      const iw = img.naturalWidth;
      const ih = img.naturalHeight;
      const cw = canvas.width;
      const ch = canvas.height;
      const base = Math.max(cw / iw, ch / ih);
      const scale = base * Math.pow(2, zoom - 1);
      const dx = cw / 2 - centerX * iw * scale;
      const dy = ch / 2 - centerY * ih * scale;
      ctx.clearRect(0, 0, cw, ch);
      ctx.imageSmoothingEnabled = zoom < 2;
      ctx.drawImage(img, dx, dy, iw * scale, ih * scale);

      // Apply circular mask to hide watermark and non-Earth regions
      // Detect disk circle once per satellite (geostationary = same position always)
      if (!window.diskCircleCache[satellite]) {
        log(`Detecting disk position for GOES-${satellite}...`);
        window.diskCircleCache[satellite] = detectDiskRadius(img);
        const pct = ((window.diskCircleCache[satellite].r / iw) * 100).toFixed(1);
        log(`Disk detected: radius=${window.diskCircleCache[satellite].r}px (${pct}% of image width)`);
        log(`To hardcode: GOES-${satellite} mask = ${pct}%`);
      }

      // Allow manual override of mask radius
      const maskInput = document.getElementById('maskRadius').value;
      let diskCircle = window.diskCircleCache[satellite];
      if (maskInput !== 'auto' && !isNaN(parseFloat(maskInput))) {
        const manualPct = parseFloat(maskInput) / 100;
        diskCircle = { cx: iw / 2, cy: ih / 2, r: iw * manualPct };
      }
      const maskedRadius = diskCircle.r * scale;
      const diskCenterX = dx + diskCircle.cx * scale;
      const diskCenterY = dy + diskCircle.cy * scale;

      // Draw black mask outside the disk
      ctx.fillStyle = '#000';
      ctx.save();
      ctx.beginPath();
      // Create path around entire canvas
      ctx.rect(0, 0, cw, ch);
      // Create circular hole for the Earth disk (subtract)
      ctx.arc(diskCenterX, diskCenterY, maskedRadius, 0, Math.PI * 2, true);
      ctx.clip('evenodd');
      ctx.fillRect(0, 0, cw, ch);
      ctx.restore();
    }

    function updateFrameInfo() {
      const isTileMode = document.getElementById('tileMode').checked;
      if (isTileMode) {
        document.getElementById('frameInfo').textContent =
          `${window.currentTileFrame + 1}/${window.sliderTimestamps.length}`;
      } else {
        document.getElementById('frameInfo').textContent =
          `${window.currentFrame + 1}/${window.imageCache.length}`;
      }
    }

    function generateTimestamps(hoursBack) {
      const now = new Date();
      const result = [];
      // GOES updates every 10 minutes, 6 times per hour
      const totalFrames = hoursBack * 6;

      for (let i = totalFrames - 1; i >= 0; i--) {
        const time = new Date(now.getTime() - i * 10 * 60 * 1000);
        // Round to nearest 10 minutes
        time.setMinutes(Math.floor(time.getMinutes() / 10) * 10);
        time.setSeconds(0);
        time.setMilliseconds(0);

        const year = time.getUTCFullYear();
        const dayOfYear = Math.floor((time - new Date(Date.UTC(year, 0, 0))) / 86400000);
        const hour = String(time.getUTCHours()).padStart(2, '0');
        const minute = String(time.getUTCMinutes()).padStart(2, '0');

        // Format: YYYYDDDHHMM for GOES-18 GeoColor
        result.push(`${year}${String(dayOfYear).padStart(3, '0')}${hour}${minute}`);
      }

      return result;
    }

    async function loadImages(hoursBack) {
      progressEl.style.display = 'block';
      window.imageCache = [];
      window.timestamps = generateTimestamps(hoursBack);
      window.currentFrame = -1;

      log(`Loading ${window.timestamps.length} GeoColor images from GOES-${satellite}...`);

      for (let i = 0; i < window.timestamps.length; i++) {
        const ts = window.timestamps[i];
        progressText.textContent = `Loading image ${i + 1}/${window.timestamps.length}...`;
        progressFill.style.width = `${((i + 1) / window.timestamps.length) * 100}%`;

        try {
          const img = await loadImage(`/goes-proxy?t=${ts}&sat=${satellite}&res=${resolution}`);
          window.imageCache.push(img);
          log(`Loaded ${ts}`);

          if (window.currentFrame === -1) {
            // First successful image - set as current frame
            window.currentFrame = i;
            drawImageToFit(img);
            updateFrameInfo();
          }
        } catch (err) {
          log(`Failed to load ${ts}: ${err.message}`);
          // Push null to maintain alignment with timestamps array
          window.imageCache.push(null);
        }
      }

      progressEl.style.display = 'none';
      log(`Loaded ${window.imageCache.length} images successfully`);

      if (window.imageCache.length === 0) {
        log('No images loaded. Try reducing the hours or check your connection.');
      }
    }

    function loadImage(url) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error('Failed to load'));
        img.src = url;
      });
    }

    // ===== TILE MODE =====
    // RAMMB SLIDER tile system from satpaper
    // Tile sizes and zoom levels vary by satellite type

    // Satellite configurations
    const TILE_CONFIG = {
      // GOES: 678px tiles, max zoom 4 (16x16 = 256 tiles, 10848px full disk)
      '18': { tileSize: 678, maxZoom: 4 },
      '19': { tileSize: 678, maxZoom: 4 },
      // Meteosat: 464px tiles, max zoom 3 (8x8 = 64 tiles, 3712px full disk)
      'meteosat9': { tileSize: 464, maxZoom: 3 },
      'meteosat10': { tileSize: 464, maxZoom: 3 },
      // Himawari: 688px tiles, max zoom 4
      'himawari': { tileSize: 688, maxZoom: 4 },
    };

    // Get zoom level config for a satellite
    function getZoomConfig(sat, zoomLevel) {
      const config = TILE_CONFIG[sat];
      if (!config) return null;
      const gridSize = Math.pow(2, zoomLevel);
      return {
        gridSize: gridSize,
        fullSize: gridSize * config.tileSize,
        tileSize: config.tileSize
      };
    }

    // Get best zoom level based on viewport zoom
    function getBestZoomLevel(viewportZoom, canvasW, canvasH, sat) {
      const config = TILE_CONFIG[sat];
      if (!config) return 0;

      const fullDiskPixels = Math.max(canvasW, canvasH);
      const neededPixels = fullDiskPixels * Math.pow(2, viewportZoom - 1);

      // Find the smallest zoom level that provides enough pixels
      for (let z = 0; z <= config.maxZoom; z++) {
        const zoomConfig = getZoomConfig(sat, z);
        if (zoomConfig.fullSize >= neededPixels * 0.8) {
          return z;
        }
      }
      return config.maxZoom;
    }

    window.tileCache = {};  // Cache tiles: { "sat_timestamp_x_y": Image }
    window.sliderTimestamps = [];  // { timestamp, date } objects
    window.currentTileFrame = -1;

    async function fetchSliderMetadata(sat) {
      const [latestResp, datesResp] = await Promise.all([
        fetch(`/slider-latest?sat=${sat}`),
        fetch(`/slider-dates?sat=${sat}`)
      ]);
      const latest = await latestResp.json();
      const dates = await datesResp.json();
      return {
        timestamps: latest.timestamps_int || [],
        dates: dates.dates_int || []
      };
    }

    function getVisibleTiles(centerX, centerY, viewportZoom, canvasW, canvasH, sliderZoom, sat) {
      // Get config for this slider zoom level and satellite
      const zoomConfig = getZoomConfig(sat, sliderZoom);
      if (!zoomConfig) return [];
      const { fullSize, gridSize, tileSize } = zoomConfig;

      // Calculate visible region based on viewport zoom
      const base = Math.max(canvasW / fullSize, canvasH / fullSize);
      const scale = base * Math.pow(2, viewportZoom - 1);

      // Visible region in image pixels
      const visW = canvasW / scale;
      const visH = canvasH / scale;
      const visLeft = centerX * fullSize - visW / 2;
      const visTop = centerY * fullSize - visH / 2;
      const visRight = visLeft + visW;
      const visBottom = visTop + visH;

      // Convert to tile coordinates (clamp to 0..gridSize-1)
      const tileLeft = Math.max(0, Math.floor(visLeft / tileSize));
      const tileTop = Math.max(0, Math.floor(visTop / tileSize));
      const tileRight = Math.min(gridSize - 1, Math.floor(visRight / tileSize));
      const tileBottom = Math.min(gridSize - 1, Math.floor(visBottom / tileSize));

      const tiles = [];
      for (let x = tileLeft; x <= tileRight; x++) {
        for (let y = tileTop; y <= tileBottom; y++) {
          tiles.push({ x, y });
        }
      }
      return tiles;
    }

    async function loadTile(sat, timestamp, date, col, row, sliderZoom) {
      // col/row are canvas coordinates, but SLIDER URL uses row_col naming (x=row, y=col)
      const key = `${sat}_${timestamp}_z${sliderZoom}_${col}_${row}`;
      if (window.tileCache[key]) return window.tileCache[key];

      const dateStr = String(date).padStart(8, '0');
      // Swap: URL x = row, URL y = col
      const url = `/slider-tile?sat=${sat}&t=${timestamp}&d=${dateStr}&x=${row}&y=${col}&z=${sliderZoom}`;
      const img = await loadImage(url);
      window.tileCache[key] = img;
      return img;
    }

    function drawTilesToCanvas(tiles, tileImages, sat, sliderZoom) {
      const zoomConfig = getZoomConfig(sat, sliderZoom);
      if (!zoomConfig) return;
      const { fullSize, tileSize } = zoomConfig;

      const cw = canvas.width;
      const ch = canvas.height;
      const base = Math.max(cw / fullSize, ch / fullSize);
      const scale = base * Math.pow(2, zoom - 1);
      const dx = cw / 2 - centerX * fullSize * scale;
      const dy = ch / 2 - centerY * fullSize * scale;

      ctx.clearRect(0, 0, cw, ch);
      ctx.imageSmoothingEnabled = zoom < 2;

      // Draw each tile at its position
      for (let i = 0; i < tiles.length; i++) {
        const tile = tiles[i];
        const img = tileImages[i];
        if (!img) continue;

        // tile.x = column, tile.y = row (canvas coordinates)
        const tileX = dx + tile.x * tileSize * scale;
        const tileY = dy + tile.y * tileSize * scale;
        const tileW = tileSize * scale;
        const tileH = tileSize * scale;

        ctx.drawImage(img, tileX, tileY, tileW, tileH);
      }

      // Apply circular mask (same as full image mode)
      const maskPct = parseFloat(document.getElementById('maskRadius').value) / 100;
      const diskRadius = fullSize * maskPct * scale;
      const diskCenterX = dx + (fullSize / 2) * scale;
      const diskCenterY = dy + (fullSize / 2) * scale;

      ctx.fillStyle = '#000';
      ctx.save();
      ctx.beginPath();
      ctx.rect(0, 0, cw, ch);
      ctx.arc(diskCenterX, diskCenterY, diskRadius, 0, Math.PI * 2, true);
      ctx.clip('evenodd');
      ctx.fillRect(0, 0, cw, ch);
      ctx.restore();
    }

    async function loadTilesForFrame(frameIdx) {
      if (frameIdx < 0 || frameIdx >= window.sliderTimestamps.length) return;

      const frame = window.sliderTimestamps[frameIdx];
      const config = TILE_CONFIG[satellite];
      if (!config) {
        log(`Tile mode not supported for satellite ${satellite}`);
        return;
      }

      // Select best zoom level based on viewport zoom
      const sliderZoom = getBestZoomLevel(zoom, canvas.width, canvas.height, satellite);
      const zoomConfig = getZoomConfig(satellite, sliderZoom);

      const tiles = getVisibleTiles(centerX, centerY, zoom, canvas.width, canvas.height, sliderZoom, satellite);
      log(`Frame ${frameIdx + 1}: ${tiles.length} tiles at zoom ${sliderZoom} (${zoomConfig.fullSize}px)`);

      const tileImages = await Promise.all(
        tiles.map(t => loadTile(satellite, frame.timestamp, frame.date, t.x, t.y, sliderZoom).catch(() => null))
      );

      drawTilesToCanvas(tiles, tileImages, satellite, sliderZoom);
      window.currentTileFrame = frameIdx;
      updateFrameInfo();
    }

    async function loadTileAnimation(hoursBack) {
      progressEl.style.display = 'block';
      window.sliderTimestamps = [];
      window.currentTileFrame = -1;

      log(`Fetching RAMMB SLIDER metadata for GOES-${satellite}...`);
      const meta = await fetchSliderMetadata(satellite);

      if (!meta.timestamps.length || !meta.dates.length) {
        log('Failed to fetch SLIDER metadata');
        progressEl.style.display = 'none';
        return;
      }

      // SLIDER timestamps are sorted newest-first
      // We need to pair each timestamp with its date (use most recent date for all)
      const framesNeeded = hoursBack * 6;  // 6 frames per hour (10 min intervals)
      const available = Math.min(framesNeeded, meta.timestamps.length);
      const currentDate = meta.dates[0];  // Most recent date

      // Take the most recent N timestamps (they're at the start of the array)
      // But reverse so animation plays oldest to newest
      for (let i = available - 1; i >= 0; i--) {
        window.sliderTimestamps.push({
          timestamp: meta.timestamps[i],
          date: currentDate
        });
      }

      log(`Prepared ${window.sliderTimestamps.length} frames from SLIDER`);

      // Load first frame
      progressText.textContent = 'Loading first frame...';
      progressFill.style.width = '50%';
      await loadTilesForFrame(0);

      progressEl.style.display = 'none';
      log(`Ready. ${window.sliderTimestamps.length} frames available.`);
    }

    async function loadLatestTile() {
      const config = TILE_CONFIG[satellite];
      if (!config) {
        log(`Tile mode not available for satellite ${satellite}, using full image`);
        document.getElementById('tileMode').checked = false;
        return loadLatestOnStart();
      }

      log(`Fetching latest SLIDER timestamp for ${satellite}...`);
      const meta = await fetchSliderMetadata(satellite);

      if (!meta.timestamps.length) {
        log('Failed to fetch SLIDER metadata');
        return;
      }

      // Arrays are sorted newest-first, so index 0 is most recent
      const latest = meta.timestamps[0];
      const latestDate = meta.dates[0];
      window.sliderTimestamps = [{ timestamp: latest, date: latestDate }];
      window.currentTileFrame = 0;

      // Select best zoom level
      const sliderZoom = getBestZoomLevel(zoom, canvas.width, canvas.height, satellite);
      const zoomConfig = getZoomConfig(satellite, sliderZoom);

      const tiles = getVisibleTiles(centerX, centerY, zoom, canvas.width, canvas.height, sliderZoom, satellite);
      log(`Loading ${tiles.length} tiles at zoom ${sliderZoom} (${zoomConfig.fullSize}px, max: ${zoomConfig.gridSize}x${zoomConfig.gridSize})...`);

      const tileImages = await Promise.all(
        tiles.map(t => loadTile(satellite, latest, latestDate, t.x, t.y, sliderZoom).catch(e => {
          log(`Tile (${t.x},${t.y}) failed`);
          return null;
        }))
      );

      drawTilesToCanvas(tiles, tileImages, satellite, sliderZoom);
      updateFrameInfo();
      log('Tile load complete.');
    }

    // Redraw tiles when view changes (for tile mode)
    let tileRefreshTimeout = null;
    function scheduleRefreshTileView() {
      if (!document.getElementById('tileMode').checked) return;
      if (window.currentTileFrame < 0) return;
      if (tileRefreshTimeout) clearTimeout(tileRefreshTimeout);
      tileRefreshTimeout = setTimeout(() => {
        loadTilesForFrame(window.currentTileFrame);
      }, 150);  // Debounce 150ms
    }

    async function refreshTileView() {
      if (!document.getElementById('tileMode').checked) return;
      if (window.currentTileFrame < 0) return;
      await loadTilesForFrame(window.currentTileFrame);
    }

    function playAnimation() {
      const isTileMode = document.getElementById('tileMode').checked;

      if (isTileMode) {
        if (window.sliderTimestamps.length === 0) {
          log('No tiles loaded. Click Load first.');
          return;
        }
      } else {
        if (window.imageCache.length === 0) {
          log('No images loaded. Click Load first.');
          return;
        }
      }

      window.isPlaying = true;
      const fps = parseInt(document.getElementById('fps').value) || 5;

      if (window.animationInterval) clearInterval(window.animationInterval);

      if (isTileMode) {
        // Tile mode animation
        window.animationInterval = setInterval(async () => {
          window.currentTileFrame = (window.currentTileFrame + 1) % window.sliderTimestamps.length;
          await loadTilesForFrame(window.currentTileFrame);
        }, 1000 / fps);
      } else {
        // Full image mode animation
        window.animationInterval = setInterval(() => {
          let attempts = 0;
          do {
            window.currentFrame = (window.currentFrame + 1) % window.imageCache.length;
            attempts++;
          } while (window.imageCache[window.currentFrame] === null && attempts < window.imageCache.length);

          drawImageToFit(window.imageCache[window.currentFrame]);
          updateFrameInfo();
        }, 1000 / fps);
      }

      log(`Playing animation at ${fps} FPS`);
    }

    function pauseAnimation() {
      window.isPlaying = false;
      if (window.animationInterval) {
        clearInterval(window.animationInterval);
        window.animationInterval = null;
      }
      log('Paused');
    }

    // Periodic sync - check for new images every 10 minutes
    setInterval(async () => {
      // Only auto-update if enabled and images are loaded
      if (!document.getElementById('autoUpdate').checked) return;
      if (window.imageCache.length === 0) return;

      log('Checking for new images...');
      const latestTs = window.timestamps[window.timestamps.length - 1];
      const now = new Date();
      const year = now.getUTCFullYear();
      const dayOfYear = Math.floor((now - new Date(Date.UTC(year, 0, 0))) / 86400000);
      const hour = String(now.getUTCHours()).padStart(2, '0');
      const minute = String(Math.floor(now.getUTCMinutes() / 10) * 10).padStart(2, '0');
      const currentTs = `${year}${String(dayOfYear).padStart(3, '0')}${hour}${minute}`;

      if (currentTs > latestTs) {
        try {
          const img = await loadImage(`/goes-proxy?t=${currentTs}&sat=${satellite}&res=${resolution}`);
          window.imageCache.push(img);
          window.timestamps.push(currentTs);
          log(`Added new image: ${currentTs}`);
          updateFrameInfo();
        } catch (err) {
          log(`No new image available yet`);
        }
      }
    }, 10 * 60 * 1000); // Every 10 minutes

    // Event listeners
    document.getElementById('load').onclick = () => {
      hours = parseInt(document.getElementById('hours').value) || 3;
      satellite = document.getElementById('satellite').value;
      resolution = document.getElementById('resolution').value;
      pauseAnimation();
      updateUrl();
      if (document.getElementById('tileMode').checked) {
        loadTileAnimation(hours);
      } else {
        loadImages(hours);
      }
    };

    document.getElementById('play').onclick = playAnimation;
    document.getElementById('pause').onclick = pauseAnimation;

    // Redraw when mask radius changes
    document.getElementById('maskRadius').addEventListener('input', () => {
      if (window.currentFrame >= 0 && window.imageCache[window.currentFrame]) {
        drawImageToFit(window.imageCache[window.currentFrame]);
      }
    });

    // Auto-update toggle feedback
    document.getElementById('autoUpdate').addEventListener('change', (e) => {
      if (e.target.checked) {
        log('Auto-update enabled: will check for new images every 10 minutes');
      } else {
        log('Auto-update disabled');
      }
    });

    document.getElementById('share').onclick = () => {
      const url = location.href;
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(url);
        log('URL copied to clipboard');
      }
    };

    // Wheel zoom (same as before but preserves animation state)
    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const isTileMode = document.getElementById('tileMode').checked;

      if (!isTileMode && window.imageCache.length === 0) return;
      if (isTileMode && window.sliderTimestamps.length === 0) return;

      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const prevZoom = zoom;
      const step = 0.25;
      zoom += (e.deltaY < 0 ? step : -step);
      if (zoom < 0.1) zoom = 0.1;
      if (zoom > 8) zoom = 8;

      // Get dimensions from image or tile config
      let iw, ih;
      if (isTileMode) {
        const config = TILE_CONFIG[satellite];
        if (!config) return;
        // Use max zoom level for coordinate calculations
        const zoomConfig = getZoomConfig(satellite, config.maxZoom);
        iw = zoomConfig.fullSize;
        ih = zoomConfig.fullSize;
      } else {
        const img = window.imageCache[window.currentFrame];
        if (!img) return;
        iw = img.naturalWidth;
        ih = img.naturalHeight;
      }

      const cw = canvas.width;
      const ch = canvas.height;
      const base = Math.max(cw / iw, ch / ih);
      const prevScale = base * Math.pow(2, prevZoom - 1);
      const newScale = base * Math.pow(2, zoom - 1);
      const imgX = (mx - (cw / 2 - centerX * iw * prevScale)) / (iw * prevScale);
      const imgY = (my - (ch / 2 - centerY * ih * prevScale)) / (ih * prevScale);
      centerX = imgX - (mx - cw / 2) / (iw * newScale);
      centerY = imgY - (my - ch / 2) / (ih * newScale);

      document.getElementById('zoom').value = String(zoom.toFixed(2));
      document.getElementById('offsetX').value = (centerX * 100).toFixed(2);
      document.getElementById('offsetY').value = (centerY * 100).toFixed(2);
      updateUrl();
      if (isTileMode) {
        scheduleRefreshTileView();
      } else {
        drawImageToFit(window.imageCache[window.currentFrame]);
      }
    }, { passive: false });

    // Pan (dragging)
    let dragging = false;
    let lastX = 0;
    let lastY = 0;

    canvas.addEventListener('mousedown', (e) => {
      dragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
    });

    window.addEventListener('mouseup', () => { dragging = false; });

    window.addEventListener('mousemove', (e) => {
      if (!dragging) return;
      const isTileMode = document.getElementById('tileMode').checked;

      if (!isTileMode && window.imageCache.length === 0) return;
      if (isTileMode && window.sliderTimestamps.length === 0) return;

      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX;
      lastY = e.clientY;

      // Get dimensions from image or tile config
      let iw, ih;
      if (isTileMode) {
        const config = TILE_CONFIG[satellite];
        if (!config) return;
        // Use max zoom level for coordinate calculations
        const zoomConfig = getZoomConfig(satellite, config.maxZoom);
        iw = zoomConfig.fullSize;
        ih = zoomConfig.fullSize;
      } else {
        const img = window.imageCache[window.currentFrame];
        if (!img) return;
        iw = img.naturalWidth;
        ih = img.naturalHeight;
      }

      const cw = canvas.width;
      const ch = canvas.height;
      const base = Math.max(cw / iw, ch / ih);
      const scale = base * Math.pow(2, zoom - 1);
      centerX -= dx / (iw * scale);
      centerY -= dy / (ih * scale);

      document.getElementById('offsetX').value = (centerX * 100).toFixed(2);
      document.getElementById('offsetY').value = (centerY * 100).toFixed(2);
      updateUrl();

      if (isTileMode) {
        scheduleRefreshTileView();
      } else {
        drawImageToFit(window.imageCache[window.currentFrame]);
      }
    });

    // Touch support for mobile
    let touchState = null;

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (window.imageCache.length === 0) return;

      const touches = e.touches;
      if (touches.length === 1) {
        // Single touch - start drag
        touchState = {
          mode: 'drag',
          lastX: touches[0].clientX,
          lastY: touches[0].clientY
        };
      } else if (touches.length === 2) {
        // Two touches - start pinch zoom
        const dx = touches[1].clientX - touches[0].clientX;
        const dy = touches[1].clientY - touches[0].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const centerTouchX = (touches[0].clientX + touches[1].clientX) / 2;
        const centerTouchY = (touches[0].clientY + touches[1].clientY) / 2;

        touchState = {
          mode: 'pinch',
          lastDistance: distance,
          centerX: centerTouchX,
          centerY: centerTouchY
        };
      }
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (!touchState || window.imageCache.length === 0) return;

      const touches = e.touches;

      if (touchState.mode === 'drag' && touches.length === 1) {
        // Handle drag
        const dx = touches[0].clientX - touchState.lastX;
        const dy = touches[0].clientY - touchState.lastY;
        touchState.lastX = touches[0].clientX;
        touchState.lastY = touches[0].clientY;

        const img = window.imageCache[window.currentFrame];
        if (!img) return;

        const iw = img.naturalWidth;
        const ih = img.naturalHeight;
        const cw = canvas.width;
        const ch = canvas.height;
        const base = Math.max(cw / iw, ch / ih);
        const scale = base * Math.pow(2, zoom - 1);
        centerX -= dx / (iw * scale);
        centerY -= dy / (ih * scale);

        document.getElementById('offsetX').value = (centerX * 100).toFixed(2);
        document.getElementById('offsetY').value = (centerY * 100).toFixed(2);
        updateUrl();
        drawImageToFit(img);
      } else if (touchState.mode === 'pinch' && touches.length === 2) {
        // Handle pinch zoom
        const dx = touches[1].clientX - touches[0].clientX;
        const dy = touches[1].clientY - touches[0].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const centerTouchX = (touches[0].clientX + touches[1].clientX) / 2;
        const centerTouchY = (touches[0].clientY + touches[1].clientY) / 2;

        const img = window.imageCache[window.currentFrame];
        if (!img) return;

        // Calculate zoom change based on distance change
        const distanceRatio = distance / touchState.lastDistance;
        const prevZoom = zoom;
        zoom *= distanceRatio;
        if (zoom < 0.1) zoom = 0.1;
        if (zoom > 8) zoom = 8;

        // Adjust center to zoom toward pinch center
        const rect = canvas.getBoundingClientRect();
        const mx = centerTouchX - rect.left;
        const my = centerTouchY - rect.top;

        const iw = img.naturalWidth;
        const ih = img.naturalHeight;
        const cw = canvas.width;
        const ch = canvas.height;
        const base = Math.max(cw / iw, ch / ih);
        const prevScale = base * Math.pow(2, prevZoom - 1);
        const newScale = base * Math.pow(2, zoom - 1);
        const imgX = (mx - (cw / 2 - centerX * iw * prevScale)) / (iw * prevScale);
        const imgY = (my - (ch / 2 - centerY * ih * prevScale)) / (ih * prevScale);
        centerX = imgX - (mx - cw / 2) / (iw * newScale);
        centerY = imgY - (my - ch / 2) / (ih * newScale);

        touchState.lastDistance = distance;
        touchState.centerX = centerTouchX;
        touchState.centerY = centerTouchY;

        document.getElementById('zoom').value = String(zoom.toFixed(2));
        document.getElementById('offsetX').value = (centerX * 100).toFixed(2);
        document.getElementById('offsetY').value = (centerY * 100).toFixed(2);
        updateUrl();
        drawImageToFit(img);
      }
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      if (e.touches.length === 0) {
        touchState = null;
      } else if (e.touches.length === 1 && touchState && touchState.mode === 'pinch') {
        // Transition from pinch to drag
        touchState = {
          mode: 'drag',
          lastX: e.touches[0].clientX,
          lastY: e.touches[0].clientY
        };
      }
    }, { passive: false });

    // Auto-load latest image on start
    async function loadLatestOnStart() {
      // Non-GOES satellites require tile mode
      const isGOES = satellite === '18' || satellite === '19';

      if (!isGOES) {
        log(`${satellite} requires tile mode - enabling automatically`);
        document.getElementById('tileMode').checked = true;
        return loadLatestTile();
      }

      log(`Loading latest image from GOES-${satellite} at ${resolution}...`);
      try {
        const img = await loadImage(`/goes-proxy?sat=${satellite}&res=${resolution}`);
        window.imageCache.push(img);
        window.currentFrame = 0;
        drawImageToFit(img);
        updateFrameInfo();
        log('Ready. Set hours and click Load to animate.');
      } catch (err) {
        log('Failed to load initial image: ' + err.message);
        log('Click Load to try again.');
      }
    }

    // Update global satellite variable when dropdown changes
    document.getElementById('satellite').addEventListener('change', (e) => {
      satellite = e.target.value;
      const isGOES = satellite === '18' || satellite === '19';
      if (!isGOES && !document.getElementById('tileMode').checked) {
        log(`${satellite} requires tile mode - click Load to fetch tiles`);
        document.getElementById('tileMode').checked = true;
      }
    });

    loadLatestOnStart();
  </script>
</body>
</html>
