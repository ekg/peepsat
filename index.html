<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>PeepSat</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 6px 8px;
      background: rgba(0,0,0,0.6);
      color: #fff;
      font-family: sans-serif;
      font-size: 12px;
      border-radius: 4px;
      z-index: 10;
    }
    #controls input, #controls select { font-size: 11px; }
    #controls button { font-size: 11px; margin: 2px; }
    #status {
      position: absolute;
      bottom: 10px;
      right: 10px;
      padding: 6px 8px;
      background: rgba(0,0,0,0.7);
      color: #0f0;
      font-family: monospace;
      font-size: 10px;
      border-radius: 4px;
      z-index: 10;
      max-width: 300px;
      max-height: 200px;
      overflow: auto;
    }
    #progress {
      position: absolute;
      bottom: 220px;
      right: 10px;
      padding: 6px 8px;
      background: rgba(0,0,0,0.8);
      color: #fff;
      font-family: sans-serif;
      font-size: 11px;
      border-radius: 4px;
      z-index: 10;
      min-width: 200px;
      display: none;
    }
    #progressBar {
      width: 100%;
      height: 20px;
      background: #333;
      border-radius: 3px;
      margin-top: 5px;
      overflow: hidden;
    }
    #progressFill {
      height: 100%;
      background: linear-gradient(90deg, #4CAF50, #8BC34A);
      width: 0%;
      transition: width 0.3s;
    }
    canvas { width: 100vw; height: 100vh; display: block; background: #000; }
  </style>
</head>
<body>
  <div id="controls">
    <label>Satellite
      <select id="satellite">
        <option value="18">GOES-18 (West/Pacific)</option>
        <option value="19">GOES-19 (East/Atlantic)</option>
      </select>
    </label>
    <label>Resolution
      <select id="resolution">
        <option value="1808x1808">1808 (Low)</option>
        <option value="5424x5424" selected>5424 (High)</option>
        <option value="10848x10848">10848 (Ultra)</option>
      </select>
    </label>
    <label>Mask %<input id="maskRadius" type="number" min="30" max="55" step="0.5" value="auto" size="4"></label>
    <br>
    <label>Offset X <input id="offsetX" size="5"></label>
    <label>Offset Y <input id="offsetY" size="5"></label>
    <label>Zoom <input id="zoom" size="3"></label>
    <br>
    <label>Hours <input id="hours" type="number" min="1" max="24" value="3" size="3"></label>
    <button id="load">Load</button>
    <button id="play">Play</button>
    <button id="pause">Pause</button>
    <label>FPS <input id="fps" type="number" min="1" max="30" value="5" size="2"></label>
    <br>
    <label>Frame <span id="frameInfo">0/0</span></label>
    <button id="share">Share</button>
  </div>
  <div id="progress">
    <div id="progressText">Loading images...</div>
    <div id="progressBar"><div id="progressFill"></div></div>
  </div>
  <div id="status"></div>
  <canvas id="canvas"></canvas>
  <script>
    const canvas = document.getElementById('canvas');
    const statusEl = document.getElementById('status');
    const progressEl = document.getElementById('progress');
    const progressText = document.getElementById('progressText');
    const progressFill = document.getElementById('progressFill');

    function log(msg) {
      statusEl.textContent += msg + "\n";
      statusEl.scrollTop = statusEl.scrollHeight;
    }

    const ctx = canvas.getContext('2d');

    // Image cache and animation - use window object directly
    window.imageCache = [];
    window.timestamps = [];
    window.currentFrame = -1;
    window.isPlaying = false;
    window.animationInterval = null;
    window.diskCircleCache = {}; // Cache detected disk per satellite: {satellite: {cx, cy, r}}

    function resize() {
      const oldW = canvas.width;
      const oldH = canvas.height;
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      // Redraw current frame on resize without changing zoom/pan
      if (window.currentFrame >= 0 && window.imageCache.length > 0) {
        drawImageToFit(window.imageCache[window.currentFrame]);
      }
    }
    window.addEventListener('resize', resize);
    resize();

    const params = new URLSearchParams(location.search);
    let centerX = parseFloat(params.get('cx') || '0.5');
    let centerY = parseFloat(params.get('cy') || '0.5');
    let zoom = parseFloat(params.get('z') || '1');
    let hours = parseInt(params.get('h') || '3');
    let satellite = params.get('sat') || '19'; // Default to GOES-19 (East)
    let resolution = params.get('res') || '5424x5424'; // Default to high res

    document.getElementById('offsetX').value = (centerX * 100).toFixed(2);
    document.getElementById('offsetY').value = (centerY * 100).toFixed(2);
    document.getElementById('zoom').value = String(zoom);
    document.getElementById('hours').value = hours;
    document.getElementById('satellite').value = satellite;
    document.getElementById('resolution').value = resolution;

    function updateUrl() {
      const p = new URLSearchParams();
      p.set('cx', centerX.toFixed(4));
      p.set('cy', centerY.toFixed(4));
      p.set('z', String(zoom));
      p.set('h', String(hours));
      p.set('sat', satellite);
      p.set('res', resolution);
      history.replaceState(null, '', '?' + p.toString());
    }

    function detectDiskRadius(img) {
      // Search from outside-in to find where Earth disk begins
      const tempCanvas = document.createElement('canvas');
      const w = img.naturalWidth;
      const h = img.naturalHeight;
      tempCanvas.width = w;
      tempCanvas.height = h;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(img, 0, 0);

      const imageData = tempCtx.getImageData(0, 0, w, h);
      const data = imageData.data;

      const cx = w / 2;
      const cy = h / 2;

      // Sample along 16 directions from outside in
      const numAngles = 16;
      let radii = [];

      for (let i = 0; i < numAngles; i++) {
        const angle = (i / numAngles) * Math.PI * 2;
        // Start from outside, move toward center
        for (let r = Math.floor(w * 0.52); r > Math.floor(w * 0.35); r--) {
          const x = Math.round(cx + r * Math.cos(angle));
          const y = Math.round(cy + r * Math.sin(angle));

          if (x < 0 || x >= w || y < 0 || y >= h) continue;

          const idx = (y * w + x) * 4;
          const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;

          // Found where Earth begins (transition from black to bright)
          if (brightness > 20) {
            radii.push(r);
            break;
          }
        }
      }

      // Use median of detected radii
      radii.sort((a, b) => a - b);
      const radius = radii.length > 0 ? radii[Math.floor(radii.length / 2)] : w * 0.49;

      return { cx, cy, r: radius };
    }

    function drawImageToFit(img) {
      if (!img) return;
      const iw = img.naturalWidth;
      const ih = img.naturalHeight;
      const cw = canvas.width;
      const ch = canvas.height;
      const base = Math.max(cw / iw, ch / ih);
      const scale = base * Math.pow(2, zoom - 1);
      const dx = cw / 2 - centerX * iw * scale;
      const dy = ch / 2 - centerY * ih * scale;
      ctx.clearRect(0, 0, cw, ch);
      ctx.imageSmoothingEnabled = zoom < 2;
      ctx.drawImage(img, dx, dy, iw * scale, ih * scale);

      // Apply circular mask to hide watermark and non-Earth regions
      // Detect disk circle once per satellite (geostationary = same position always)
      if (!window.diskCircleCache[satellite]) {
        log(`Detecting disk position for GOES-${satellite}...`);
        window.diskCircleCache[satellite] = detectDiskRadius(img);
        const pct = ((window.diskCircleCache[satellite].r / iw) * 100).toFixed(1);
        log(`Disk detected: radius=${window.diskCircleCache[satellite].r}px (${pct}% of image width)`);
        log(`To hardcode: GOES-${satellite} mask = ${pct}%`);
      }

      // Allow manual override of mask radius
      const maskInput = document.getElementById('maskRadius').value;
      let diskCircle = window.diskCircleCache[satellite];
      if (maskInput !== 'auto' && !isNaN(parseFloat(maskInput))) {
        const manualPct = parseFloat(maskInput) / 100;
        diskCircle = { cx: iw / 2, cy: ih / 2, r: iw * manualPct };
      }
      const maskedRadius = diskCircle.r * scale;
      const diskCenterX = dx + diskCircle.cx * scale;
      const diskCenterY = dy + diskCircle.cy * scale;

      // Draw black mask outside the disk
      ctx.fillStyle = '#000';
      ctx.save();
      ctx.beginPath();
      // Create path around entire canvas
      ctx.rect(0, 0, cw, ch);
      // Create circular hole for the Earth disk (subtract)
      ctx.arc(diskCenterX, diskCenterY, maskedRadius, 0, Math.PI * 2, true);
      ctx.clip('evenodd');
      ctx.fillRect(0, 0, cw, ch);
      ctx.restore();
    }

    function updateFrameInfo() {
      document.getElementById('frameInfo').textContent =
        `${window.currentFrame + 1}/${window.imageCache.length}`;
    }

    function generateTimestamps(hoursBack) {
      const now = new Date();
      const result = [];
      // GOES updates every 10 minutes, 6 times per hour
      const totalFrames = hoursBack * 6;

      for (let i = totalFrames - 1; i >= 0; i--) {
        const time = new Date(now.getTime() - i * 10 * 60 * 1000);
        // Round to nearest 10 minutes
        time.setMinutes(Math.floor(time.getMinutes() / 10) * 10);
        time.setSeconds(0);
        time.setMilliseconds(0);

        const year = time.getUTCFullYear();
        const dayOfYear = Math.floor((time - new Date(Date.UTC(year, 0, 0))) / 86400000);
        const hour = String(time.getUTCHours()).padStart(2, '0');
        const minute = String(time.getUTCMinutes()).padStart(2, '0');

        // Format: YYYYDDDHHMM for GOES-18 GeoColor
        result.push(`${year}${String(dayOfYear).padStart(3, '0')}${hour}${minute}`);
      }

      return result;
    }

    async function loadImages(hoursBack) {
      progressEl.style.display = 'block';
      window.imageCache = [];
      window.timestamps = generateTimestamps(hoursBack);
      window.currentFrame = -1;

      log(`Loading ${window.timestamps.length} GeoColor images from GOES-${satellite}...`);

      for (let i = 0; i < window.timestamps.length; i++) {
        const ts = window.timestamps[i];
        progressText.textContent = `Loading image ${i + 1}/${window.timestamps.length}...`;
        progressFill.style.width = `${((i + 1) / window.timestamps.length) * 100}%`;

        try {
          const img = await loadImage(`/goes-proxy?t=${ts}&sat=${satellite}&res=${resolution}`);
          window.imageCache.push(img);
          log(`Loaded ${ts}`);

          if (window.currentFrame === -1) {
            // First successful image - set as current frame
            window.currentFrame = i;
            drawImageToFit(img);
            updateFrameInfo();
          }
        } catch (err) {
          log(`Failed to load ${ts}: ${err.message}`);
          // Push null to maintain alignment with timestamps array
          window.imageCache.push(null);
        }
      }

      progressEl.style.display = 'none';
      log(`Loaded ${window.imageCache.length} images successfully`);

      if (window.imageCache.length === 0) {
        log('No images loaded. Try reducing the hours or check your connection.');
      }
    }

    function loadImage(url) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error('Failed to load'));
        img.src = url;
      });
    }

    function playAnimation() {
      if (window.imageCache.length === 0) {
        log('No images loaded. Click Load first.');
        return;
      }

      window.isPlaying = true;
      const fps = parseInt(document.getElementById('fps').value) || 5;

      if (window.animationInterval) clearInterval(window.animationInterval);

      window.animationInterval = setInterval(() => {
        // Advance to next frame, skipping null entries
        let attempts = 0;
        do {
          window.currentFrame = (window.currentFrame + 1) % window.imageCache.length;
          attempts++;
        } while (window.imageCache[window.currentFrame] === null && attempts < window.imageCache.length);

        drawImageToFit(window.imageCache[window.currentFrame]);
        updateFrameInfo();
      }, 1000 / fps);

      log(`Playing animation at ${fps} FPS`);
    }

    function pauseAnimation() {
      window.isPlaying = false;
      if (window.animationInterval) {
        clearInterval(window.animationInterval);
        window.animationInterval = null;
      }
      log('Paused');
    }

    // Periodic sync - check for new images every 10 minutes
    setInterval(async () => {
      if (window.imageCache.length === 0) return;

      log('Checking for new images...');
      const latestTs = window.timestamps[window.timestamps.length - 1];
      const now = new Date();
      const year = now.getUTCFullYear();
      const dayOfYear = Math.floor((now - new Date(Date.UTC(year, 0, 0))) / 86400000);
      const hour = String(now.getUTCHours()).padStart(2, '0');
      const minute = String(Math.floor(now.getUTCMinutes() / 10) * 10).padStart(2, '0');
      const currentTs = `${year}${String(dayOfYear).padStart(3, '0')}${hour}${minute}`;

      if (currentTs > latestTs) {
        try {
          const img = await loadImage(`/goes-proxy?t=${currentTs}&sat=${satellite}&res=${resolution}`);
          window.imageCache.push(img);
          window.timestamps.push(currentTs);
          log(`Added new image: ${currentTs}`);
          updateFrameInfo();
        } catch (err) {
          log(`No new image available yet`);
        }
      }
    }, 10 * 60 * 1000); // Every 10 minutes

    // Event listeners
    document.getElementById('load').onclick = () => {
      hours = parseInt(document.getElementById('hours').value) || 3;
      satellite = document.getElementById('satellite').value;
      resolution = document.getElementById('resolution').value;
      pauseAnimation();
      updateUrl();
      loadImages(hours);
    };

    document.getElementById('play').onclick = playAnimation;
    document.getElementById('pause').onclick = pauseAnimation;

    document.getElementById('share').onclick = () => {
      const url = location.href;
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(url);
        log('URL copied to clipboard');
      }
    };

    // Wheel zoom (same as before but preserves animation state)
    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      if (window.imageCache.length === 0) return;

      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const prevZoom = zoom;
      const step = 0.25;
      zoom += (e.deltaY < 0 ? step : -step);
      if (zoom < 0.1) zoom = 0.1;
      if (zoom > 8) zoom = 8;

      const img = window.imageCache[window.currentFrame];
      if (!img) return;

      const iw = img.naturalWidth;
      const ih = img.naturalHeight;
      const cw = canvas.width;
      const ch = canvas.height;
      const base = Math.max(cw / iw, ch / ih);
      const prevScale = base * Math.pow(2, prevZoom - 1);
      const newScale = base * Math.pow(2, zoom - 1);
      const imgX = (mx - (cw / 2 - centerX * iw * prevScale)) / (iw * prevScale);
      const imgY = (my - (ch / 2 - centerY * ih * prevScale)) / (ih * prevScale);
      centerX = imgX - (mx - cw / 2) / (iw * newScale);
      centerY = imgY - (my - ch / 2) / (ih * newScale);

      document.getElementById('zoom').value = String(zoom.toFixed(2));
      document.getElementById('offsetX').value = (centerX * 100).toFixed(2);
      document.getElementById('offsetY').value = (centerY * 100).toFixed(2);
      updateUrl();
      drawImageToFit(img);
    }, { passive: false });

    // Pan (dragging)
    let dragging = false;
    let lastX = 0;
    let lastY = 0;

    canvas.addEventListener('mousedown', (e) => {
      dragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
    });

    window.addEventListener('mouseup', () => { dragging = false; });

    window.addEventListener('mousemove', (e) => {
      if (!dragging || window.imageCache.length === 0) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX;
      lastY = e.clientY;

      const img = window.imageCache[window.currentFrame];
      if (!img) return;

      const iw = img.naturalWidth;
      const ih = img.naturalHeight;
      const cw = canvas.width;
      const ch = canvas.height;
      const base = Math.max(cw / iw, ch / ih);
      const scale = base * Math.pow(2, zoom - 1);
      centerX -= dx / (iw * scale);
      centerY -= dy / (ih * scale);

      document.getElementById('offsetX').value = (centerX * 100).toFixed(2);
      document.getElementById('offsetY').value = (centerY * 100).toFixed(2);
      updateUrl();
      drawImageToFit(img);
    });

    // Touch support for mobile
    let touchState = null;

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (window.imageCache.length === 0) return;

      const touches = e.touches;
      if (touches.length === 1) {
        // Single touch - start drag
        touchState = {
          mode: 'drag',
          lastX: touches[0].clientX,
          lastY: touches[0].clientY
        };
      } else if (touches.length === 2) {
        // Two touches - start pinch zoom
        const dx = touches[1].clientX - touches[0].clientX;
        const dy = touches[1].clientY - touches[0].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const centerTouchX = (touches[0].clientX + touches[1].clientX) / 2;
        const centerTouchY = (touches[0].clientY + touches[1].clientY) / 2;

        touchState = {
          mode: 'pinch',
          lastDistance: distance,
          centerX: centerTouchX,
          centerY: centerTouchY
        };
      }
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (!touchState || window.imageCache.length === 0) return;

      const touches = e.touches;

      if (touchState.mode === 'drag' && touches.length === 1) {
        // Handle drag
        const dx = touches[0].clientX - touchState.lastX;
        const dy = touches[0].clientY - touchState.lastY;
        touchState.lastX = touches[0].clientX;
        touchState.lastY = touches[0].clientY;

        const img = window.imageCache[window.currentFrame];
        if (!img) return;

        const iw = img.naturalWidth;
        const ih = img.naturalHeight;
        const cw = canvas.width;
        const ch = canvas.height;
        const base = Math.max(cw / iw, ch / ih);
        const scale = base * Math.pow(2, zoom - 1);
        centerX -= dx / (iw * scale);
        centerY -= dy / (ih * scale);

        document.getElementById('offsetX').value = (centerX * 100).toFixed(2);
        document.getElementById('offsetY').value = (centerY * 100).toFixed(2);
        updateUrl();
        drawImageToFit(img);
      } else if (touchState.mode === 'pinch' && touches.length === 2) {
        // Handle pinch zoom
        const dx = touches[1].clientX - touches[0].clientX;
        const dy = touches[1].clientY - touches[0].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const centerTouchX = (touches[0].clientX + touches[1].clientX) / 2;
        const centerTouchY = (touches[0].clientY + touches[1].clientY) / 2;

        const img = window.imageCache[window.currentFrame];
        if (!img) return;

        // Calculate zoom change based on distance change
        const distanceRatio = distance / touchState.lastDistance;
        const prevZoom = zoom;
        zoom *= distanceRatio;
        if (zoom < 0.1) zoom = 0.1;
        if (zoom > 8) zoom = 8;

        // Adjust center to zoom toward pinch center
        const rect = canvas.getBoundingClientRect();
        const mx = centerTouchX - rect.left;
        const my = centerTouchY - rect.top;

        const iw = img.naturalWidth;
        const ih = img.naturalHeight;
        const cw = canvas.width;
        const ch = canvas.height;
        const base = Math.max(cw / iw, ch / ih);
        const prevScale = base * Math.pow(2, prevZoom - 1);
        const newScale = base * Math.pow(2, zoom - 1);
        const imgX = (mx - (cw / 2 - centerX * iw * prevScale)) / (iw * prevScale);
        const imgY = (my - (ch / 2 - centerY * ih * prevScale)) / (ih * prevScale);
        centerX = imgX - (mx - cw / 2) / (iw * newScale);
        centerY = imgY - (my - ch / 2) / (ih * newScale);

        touchState.lastDistance = distance;
        touchState.centerX = centerTouchX;
        touchState.centerY = centerTouchY;

        document.getElementById('zoom').value = String(zoom.toFixed(2));
        document.getElementById('offsetX').value = (centerX * 100).toFixed(2);
        document.getElementById('offsetY').value = (centerY * 100).toFixed(2);
        updateUrl();
        drawImageToFit(img);
      }
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      if (e.touches.length === 0) {
        touchState = null;
      } else if (e.touches.length === 1 && touchState && touchState.mode === 'pinch') {
        // Transition from pinch to drag
        touchState = {
          mode: 'drag',
          lastX: e.touches[0].clientX,
          lastY: e.touches[0].clientY
        };
      }
    }, { passive: false });

    // Auto-load latest image on start
    async function loadLatestOnStart() {
      log(`Loading latest image from GOES-${satellite} at ${resolution}...`);
      try {
        const img = await loadImage(`/goes-proxy?sat=${satellite}&res=${resolution}`);
        window.imageCache.push(img);
        window.currentFrame = 0;
        drawImageToFit(img);
        updateFrameInfo();
        log('Ready. Set hours and click Load to animate.');
      } catch (err) {
        log('Failed to load initial image: ' + err.message);
        log('Click Load to try again.');
      }
    }
    loadLatestOnStart();
  </script>
</body>
</html>
